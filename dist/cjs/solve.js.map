{"version":3,"file":"solve.js","sourceRoot":"","sources":["../../src/solve.ts"],"names":[],"mappings":"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","sourcesContent":["import { getParsedNftAccountsByOwner } from './metaplex/nfts';\nimport {\n    getDomainKey as getSPLDomainKey,\n    NameRegistryState,\n    getAllDomains as getAllSNSDomains,\n    performReverseLookup as performSNSReverseLookup,\n    getFavoriteDomain,\n} from '@bonfida/spl-name-service';\nimport {\n    findOwnedNameAccountsForUser,\n    getDomainKey,\n    NameRecordHeader,\n    TldParser,\n} from '@onsol/tldparser';\nimport { PublicKey, Connection } from '@solana/web3.js';\nimport { Domain } from './model';\nimport {\n    findCollectionMint,\n    findNameHouse,\n    findNameRecord,\n    findTldHouse,\n} from './pda';\nimport pLimit from 'p-limit';\nimport { NftRecord } from './types/nft_record';\nimport { chunkArrayPublicKeys } from './utils';\nimport { BN } from 'bn.js';\nimport { MainDomain } from './types/main_domain';\nimport { Protocol } from './types/protocol';\n\n/**\n * TldSolve, solves for ans and sns domains.\n */\nexport class TldSolve {\n    /**\n     * Creates an instance of TldSolve.\n     *\n     * @constructor\n     * @param {Connection} connection\n     */\n    constructor(private readonly connection: Connection) {}\n\n    /**\n     * retrieves userAccount main domain or favorite domain in sns.\n     *\n     * @async\n     * @param {(PublicKey | string)} userAccount of interest.\n     * @param {Protocol} [protocol=Protocol.ANS]\n     * @returns {(Promise<MainDomain | undefined>)}\n     */\n    async getMainDomain(\n        userAccount: PublicKey | string,\n        protocol: Protocol = Protocol.ANS,\n    ): Promise<MainDomain | undefined> {\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        if (protocol === Protocol.SNS) {\n            // sns\n            const favoriteDomain = await getFavoriteDomain(\n                this.connection,\n                userAccount,\n            );\n            return {\n                nameAccount: favoriteDomain.domain,\n                tld: '.sol',\n                domain: favoriteDomain.reverse,\n            };\n        }\n        // ans\n        const parser = new TldParser(this.connection);\n        const mainDomain = await parser.getMainDomain(userAccount);\n        return mainDomain;\n    }\n\n    /**\n     * resolves any domain name.\n     *\n     * @async\n     * @param {string} domain to be resolved.\n     * @returns {(Promise<NameRecordHeader | NameRegistryState | undefined>)}\n     */\n    async resolveDomain(\n        domain: string,\n    ): Promise<NameRecordHeader | NameRegistryState | undefined> {\n        const domainSplit = domain.split('.');\n        const tldName = domainSplit.at(-1);\n        if (tldName === 'sol') {\n            // sns\n            const { pubkey } = await getSPLDomainKey(domain);\n            const { registry } = await NameRegistryState.retrieve(\n                this.connection,\n                pubkey,\n            );\n            return registry;\n        }\n        // ans\n        const { pubkey } = await getDomainKey(domain);\n        const nameRecordHeader = await NameRecordHeader.fromAccountAddress(\n            this.connection,\n            pubkey,\n        );\n        return nameRecordHeader;\n    }\n\n    /**\n     * retrieve owner from a domain.\n     *\n     * @async\n     * @param {string} domain to retrieve owner of.\n     * @returns {(Promise<PublicKey | undefined>)}\n     */\n    async getOwnerFromDomain(domain: string): Promise<PublicKey | undefined> {\n        const domainSplit = domain.split('.');\n        const tldName = domainSplit.at(-1);\n        if (tldName === 'sol') {\n            // sns\n            const { pubkey } = await getSPLDomainKey(domain);\n            const { registry } = await NameRegistryState.retrieve(\n                this.connection,\n                pubkey,\n            );\n            return registry.owner;\n        }\n        // ans\n        const { pubkey } = await getDomainKey(domain);\n        const nameRecordHeader = await NameRecordHeader.fromAccountAddress(\n            this.connection,\n            pubkey,\n        );\n        return nameRecordHeader?.owner;\n    }\n\n    /**\n     * retrieves nameAccount publickey from domain name.\n     *\n     * @async\n     * @param {string} domain to retrieve name account.\n     * @returns {(Promise<PublicKey | undefined>)}\n     */\n    async getNameAccountFromDomain(\n        domain: string,\n    ): Promise<PublicKey | undefined> {\n        const domainSplit = domain.split('.');\n        if (domainSplit.length > 2) return;\n        const tldName = domainSplit.at(-1);\n\n        if (tldName === 'sol') {\n            // solana\n            const { pubkey } = await getSPLDomainKey(domain);\n            return pubkey;\n        }\n        // ans\n        const { pubkey } = await getDomainKey(domain);\n        return pubkey;\n    }\n\n    /**\n     * retrieve all domains from user based on protocol.\n     *\n     * @async\n     * @param {(PublicKey | string)} userAccount to be looked for.\n     * @param {Protocol} [protocol=Protocol.ANS]\n     * @returns {(Promise<PublicKey[] | undefined>)}\n     */\n    async getAllDomainsFromUser(\n        userAccount: PublicKey | string,\n        protocol: Protocol = Protocol.ANS,\n    ): Promise<PublicKey[] | undefined> {\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        switch (protocol) {\n            case Protocol.ANS:\n                const domainsANS = await findOwnedNameAccountsForUser(\n                    this.connection,\n                    userAccount,\n                    undefined,\n                );\n                return domainsANS;\n            case Protocol.SNS:\n                const domainsSNS = await getAllSNSDomains(\n                    this.connection,\n                    userAccount,\n                );\n                return domainsSNS;\n            default:\n                // retrieves from both ans and sns.\n                const domainsANSDefault = await findOwnedNameAccountsForUser(\n                    this.connection,\n                    userAccount,\n                    undefined,\n                );\n                const domainsSNSDefault = await getAllSNSDomains(\n                    this.connection,\n                    userAccount,\n                );\n                const allDomains = domainsANSDefault.concat(domainsSNSDefault);\n                return allDomains;\n        }\n    }\n\n    /**\n     * retrieve all domains from user based on tld (e.g. abc, sol, bonk, etc.).\n     *\n     * @async\n     * @param {(PublicKey | string)} userAccount to be looked for.\n     * @param {string} tld without the dot.\n     * @returns {(Promise<PublicKey[] | undefined>)}\n     */\n    async getAllDomainsFromUserFromTld(\n        userAccount: PublicKey | string,\n        tld: string,\n    ): Promise<PublicKey[] | undefined> {\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        if (tld === 'sol') {\n            const domainsSPL = await getAllSNSDomains(\n                this.connection,\n                userAccount,\n            );\n            return domainsSPL;\n        }\n        const parser = new TldParser(this.connection);\n        const domainsANS = await parser.getAllUserDomainsFromTld(\n            userAccount,\n            tld,\n        );\n        return domainsANS;\n    }\n\n    /**\n     * reverse lookup for nameAccount public key, to retrieve domain name.\n     * works for both ANS and SNS.\n     *\n     * @async\n     * @param {(PublicKey | string)} nameAccount domain publickey\n     * @param {?(PublicKey | string)} [parentAccountOwner] parentAccount is the nameclass for the reverse lookup account. leave empty for SNS.\n     * @returns {(Promise<string | undefined>)}\n     */\n    async reverseLookupNameAccountWithKnownParent(\n        nameAccount: PublicKey | string,\n        parentAccountOwner?: PublicKey | string,\n    ): Promise<string | undefined> {\n        const parser = new TldParser(this.connection);\n        if (parentAccountOwner) {\n            const domainName = await parser.reverseLookupNameAccount(\n                nameAccount,\n                parentAccountOwner,\n            );\n            return domainName;\n        } else {\n            if (typeof nameAccount == 'string') {\n                nameAccount = new PublicKey(nameAccount);\n            }\n            const domainName = await performSNSReverseLookup(\n                this.connection,\n                nameAccount,\n            );\n            return domainName;\n        }\n    }\n\n    /**\n     * reverse lookup for nameAccount public key, to retrieve domain name.\n     * based on protocol.\n     *\n     * @async\n     * @param {(PublicKey | string)} nameAccount\n     * @param {Protocol} [protocol=Protocol.ANS]\n     * @returns {(Promise<string | undefined>)}\n     */\n    async reverseLookupNameAccount(\n        nameAccount: PublicKey | string,\n        protocol: Protocol = Protocol.ANS,\n    ): Promise<string | undefined> {\n        if (typeof nameAccount == 'string') {\n            nameAccount = new PublicKey(nameAccount);\n        }\n        switch (protocol) {\n            case Protocol.ANS:\n                const nameRecordHeaderANS =\n                    await NameRecordHeader.fromAccountAddress(\n                        this.connection,\n                        nameAccount,\n                    );\n                if (!nameRecordHeaderANS) return;\n                const tldParser = new TldParser(this.connection);\n                const tldFound = await tldParser.getTldFromParentAccount(\n                    nameRecordHeaderANS.parentName,\n                );\n                const [tldHouseKey] = findTldHouse(tldFound);\n                const domainNameANS = await tldParser.reverseLookupNameAccount(\n                    nameAccount,\n                    tldHouseKey,\n                );\n                return domainNameANS;\n            case Protocol.SNS:\n                let domainNameSNS = await performSNSReverseLookup(\n                    this.connection,\n                    nameAccount,\n                );\n                return domainNameSNS;\n            default:\n                let domainName: string;\n                domainName = await performSNSReverseLookup(\n                    this.connection,\n                    nameAccount,\n                );\n                if (domainName) return domainName;\n                const nameRecordHeader =\n                    await NameRecordHeader.fromAccountAddress(\n                        this.connection,\n                        nameAccount,\n                    );\n                if (!nameRecordHeader) return;\n                const parser = new TldParser(this.connection);\n                const tld = await parser.getTldFromParentAccount(\n                    nameRecordHeader.parentName,\n                );\n                const [tldHouse] = findTldHouse(tld);\n                domainName = await parser.reverseLookupNameAccount(\n                    nameAccount,\n                    tldHouse,\n                );\n                return domainName;\n        }\n    }\n\n    /**\n     * Batch resolve any ANS domains held by the userAccount\n     *\n     * @async\n     * @param {(PublicKey | string)} userAccount domain owner\n     * @param {?string} [heliusApiKey] optional helius api key.\n     * @param {('abc' | 'bonk' | 'poor')} [tld='abc']\n     * @param {number} [limitRPS=10] limits depend on your rpc connection rps limit/3.\n     * @returns {(Promise<Domain[] | undefined>)}\n     */\n    async batchResolveANSDomains(\n        userAccount: PublicKey | string,\n        heliusApiKey?: string,\n        tld: 'abc' | 'bonk' | 'poor' = 'abc',\n        limitRPS: number = 10,\n    ): Promise<Domain[] | undefined> {\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        const [tldHouse] = findTldHouse('.' + tld);\n        let accounts: string[] = [];\n        const ansDomains = await this.getAllDomainsFromUserFromTld(\n            userAccount,\n            tld,\n        );\n        if (!ansDomains) return;\n        accounts = ansDomains.map((keys: PublicKey) => keys.toString());\n        let nftRecords: NftRecord[] = [];\n        let activeNfts = [];\n        const limit = pLimit(limitRPS);\n        if (heliusApiKey) {\n            const [nameHouse] = findNameHouse(tldHouse);\n            const [tldCollection] = findCollectionMint(tldHouse);\n            const userNfts = await getParsedNftAccountsByOwner(\n                this.connection,\n                userAccount,\n                heliusApiKey,\n            );\n\n            activeNfts = userNfts.filter(\n                (t: any) =>\n                    t?.onChainData?.collection &&\n                    t?.onChainData?.collection.verified &&\n                    // domains verified collection.\n                    t?.onChainData?.collection?.key?.toString() ===\n                        tldCollection.toString(),\n            );\n\n            const nftRecordsSet = new Set<NftRecord>();\n            const activeRecordPromises = activeNfts.map((activeAccount: any) =>\n                limit(async () => {\n                    let domain = activeAccount.offChainData?.name;\n                    if (!domain) {\n                        domain = activeAccount.onChainData.data.name;\n                    }\n                    const { pubkey: nameAccount } = await getDomainKey(\n                        `${domain}.${tld}`,\n                    );\n                    const [nftRecordAccount] = findNameRecord(\n                        nameAccount,\n                        nameHouse,\n                    );\n                    const nftRecordData = await NftRecord.fromAccountAddress(\n                        this.connection,\n                        nftRecordAccount,\n                    );\n                    nftRecordsSet.add(nftRecordData);\n                }),\n            );\n\n            await Promise.all(activeRecordPromises);\n            nftRecords = [...nftRecordsSet.values()];\n        }\n        let nameAccountsNftRecords: string[] = [];\n        if (nftRecords) {\n            nameAccountsNftRecords = nftRecords?.map((nftRecord: NftRecord) =>\n                nftRecord.nameAccount.toString(),\n            );\n        }\n        const fetchableAccounts: PublicKey[] = [];\n        [...nameAccountsNftRecords, ...accounts].forEach(keys =>\n            fetchableAccounts.push(new PublicKey(keys)),\n        );\n        const chunkedFetchableAccounts: PublicKey[][] = chunkArrayPublicKeys(\n            fetchableAccounts,\n            100,\n        );\n\n        const fetchedAccountDetails: Domain[] = [];\n        for (let fetchableAccountsChunked in chunkedFetchableAccounts) {\n            const accounts = await this.connection.getMultipleAccountsInfo(\n                chunkedFetchableAccounts[fetchableAccountsChunked],\n            );\n            const promises = accounts.map((account, index) =>\n                limit(async () => {\n                    if (!account?.data) return;\n                    const domainRecord =\n                        NameRecordHeader.fromAccountInfo(account);\n                    if (!domainRecord) return;\n                    const domainName = (\n                        await this.reverseLookupNameAccount(\n                            chunkedFetchableAccounts[fetchableAccountsChunked][\n                                index\n                            ],\n                        )\n                    )?.trim();\n                    let nftDetails: any = { isNft: false };\n                    try {\n                        if (\n                            heliusApiKey &&\n                            nftRecords.length > 0 &&\n                            nftRecords[index]?.nftMintAccount\n                        ) {\n                            nftDetails = {\n                                isNft: true,\n                                nft: nftRecords[index].nftMintAccount,\n                                metadata: activeNfts[index],\n                            };\n                        }\n                    } catch {}\n                    const domainDetails: Domain = {\n                        parentName: domainRecord.parentName,\n                        owner: domainRecord.owner,\n                        expiresAt: domainRecord.expiresAt,\n                        domainName: domainName,\n                        domainAccount:\n                            chunkedFetchableAccounts[fetchableAccountsChunked][\n                                index\n                            ],\n                        ...nftDetails,\n                    };\n                    fetchedAccountDetails.push(domainDetails);\n                }),\n            );\n\n            await Promise.all(promises);\n        }\n        if (fetchedAccountDetails.length > 0) {\n            fetchedAccountDetails.sort((a, b) =>\n                a.domainName.localeCompare(b.domainName, undefined, {\n                    numeric: true,\n                    sensitivity: 'base',\n                }),\n            );\n        }\n\n        return fetchedAccountDetails;\n    }\n}\n"]}