{"version":3,"file":"solve.js","sourceRoot":"","sources":["../../src/solve.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    getDomainKey as getSPLDomainKey,\n    NameRegistryState,\n    getAllDomains as getAllSNSDomains,\n    performReverseLookup as performSNSReverseLookup,\n    getFavoriteDomain,\n} from '@bonfida/spl-name-service';\nimport {\n    findOwnedNameAccountsForUser,\n    getDomainKey,\n    NameRecordHeader,\n    TldParser,\n} from '@onsol/tldparser';\nimport { PublicKey, Connection } from '@solana/web3.js';\nimport { findTldHouse } from './pda';\nimport { MainDomain } from './types/main_domain';\nimport { Protocol } from './types/protocol';\n\n/**\n * TldSolve, solves for ans and sns domains.\n */\nexport class TldSolve {\n    /**\n     * Creates an instance of TldSolve.\n     *\n     * @constructor\n     * @param {Connection} connection\n     */\n    constructor(private readonly connection: Connection) {}\n\n    /**\n     * retrieves userAccount main domain or favorite domain in sns.\n     *\n     * @async\n     * @param {(PublicKey | string)} userAccount of interest.\n     * @param {Protocol} [protocol=Protocol.ANS]\n     * @returns {(Promise<MainDomain | undefined>)}\n     */\n    async getMainDomain(\n        userAccount: PublicKey | string,\n        protocol: Protocol = Protocol.ANS,\n    ): Promise<MainDomain | undefined> {\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        if (protocol === Protocol.SNS) {\n            // sns\n            const favoriteDomain = await getFavoriteDomain(\n                this.connection,\n                userAccount,\n            );\n            return {\n                nameAccount: favoriteDomain.domain,\n                tld: '.sol',\n                domain: favoriteDomain.reverse,\n            };\n        }\n        // ans\n        const parser = new TldParser(this.connection);\n        const mainDomain = await parser.getMainDomain(userAccount);\n        return mainDomain;\n    }\n\n    /**\n     * resolves any domain name to its raw state.\n     *\n     * @async\n     * @param {string} domain to be resolved.\n     * @returns {(Promise<NameRecordHeader | NameRegistryState | undefined>)}\n     */\n    async resolveDomain(\n        domain: string,\n    ): Promise<NameRecordHeader | NameRegistryState | undefined> {\n        const domainSplit = domain.split('.');\n        const tldName = domainSplit.at(-1);\n        if (tldName === 'sol') {\n            // sns\n            const { pubkey } = await getSPLDomainKey(domain);\n            const { registry } = await NameRegistryState.retrieve(\n                this.connection,\n                pubkey,\n            );\n            return registry;\n        }\n        // ans\n        const { pubkey } = await getDomainKey(domain);\n        const nameRecordHeader = await NameRecordHeader.fromAccountAddress(\n            this.connection,\n            pubkey,\n        );\n        return nameRecordHeader;\n    }\n\n    /**\n     * retrieve owner from a domain.\n     *\n     * @async\n     * @param {string} domain to retrieve owner of.\n     * @returns {(Promise<PublicKey | undefined>)}\n     */\n    async getOwnerFromDomain(domain: string): Promise<PublicKey | undefined> {\n        const domainSplit = domain.split('.');\n        const tldName = domainSplit.at(-1);\n        if (tldName === 'sol') {\n            // sns\n            const { pubkey } = await getSPLDomainKey(domain);\n            const { registry } = await NameRegistryState.retrieve(\n                this.connection,\n                pubkey,\n            );\n            return registry.owner;\n        }\n        // ans\n        const parser = new TldParser(this.connection);\n        const owner = await parser.getOwnerFromDomainTld(domain);\n        return owner;\n    }\n\n    /**\n     * retrieves nameAccount publickey from domain name.\n     *\n     * @async\n     * @param {string} domain to retrieve name account.\n     * @returns {(Promise<PublicKey | undefined>)}\n     */\n    async getNameAccountFromDomain(\n        domain: string,\n    ): Promise<PublicKey | undefined> {\n        const domainSplit = domain.split('.');\n        if (domainSplit.length > 2) return;\n        const tldName = domainSplit.at(-1);\n\n        if (tldName === 'sol') {\n            // solana\n            const { pubkey } = await getSPLDomainKey(domain);\n            return pubkey;\n        }\n        // ans\n        const { pubkey } = await getDomainKey(domain);\n        return pubkey;\n    }\n\n    /**\n     * retrieve all domains from user based on protocol.\n     *\n     * @async\n     * @param {(PublicKey | string)} userAccount to be looked for.\n     * @param {Protocol} [protocol=Protocol.ANS]\n     * @returns {(Promise<PublicKey[] | undefined>)}\n     */\n    async getAllDomainsFromUser(\n        userAccount: PublicKey | string,\n        protocol: Protocol = Protocol.ANS,\n    ): Promise<PublicKey[] | undefined> {\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        switch (protocol) {\n            case Protocol.ANS:\n                const domainsANS = await findOwnedNameAccountsForUser(\n                    this.connection,\n                    userAccount,\n                    undefined,\n                );\n                return domainsANS;\n            case Protocol.SNS:\n                const domainsSNS = await getAllSNSDomains(\n                    this.connection,\n                    userAccount,\n                );\n                return domainsSNS;\n            default:\n                // retrieves from both ans and sns.\n                const domainsANSDefault = await findOwnedNameAccountsForUser(\n                    this.connection,\n                    userAccount,\n                    undefined,\n                );\n                const domainsSNSDefault = await getAllSNSDomains(\n                    this.connection,\n                    userAccount,\n                );\n                const allDomains = domainsANSDefault.concat(domainsSNSDefault);\n                return allDomains;\n        }\n    }\n\n    /**\n     * retrieve all domains from user based on tld (e.g. abc, sol, bonk, etc.).\n     *\n     * @async\n     * @param {(PublicKey | string)} userAccount to be looked for.\n     * @param {string} tld without the dot.\n     * @returns {(Promise<PublicKey[] | undefined>)}\n     */\n    async getAllDomainsFromUserFromTld(\n        userAccount: PublicKey | string,\n        tld: string,\n    ): Promise<PublicKey[] | undefined> {\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        if (tld === 'sol') {\n            const domainsSPL = await getAllSNSDomains(\n                this.connection,\n                userAccount,\n            );\n            return domainsSPL;\n        }\n        const parser = new TldParser(this.connection);\n        const domainsANS = await parser.getAllUserDomainsFromTld(\n            userAccount,\n            tld,\n        );\n        return domainsANS;\n    }\n\n    /**\n     * reverse lookup for nameAccount public key, to retrieve domain name.\n     * works for both ANS and SNS.\n     *\n     * @async\n     * @param {(PublicKey | string)} nameAccount domain publickey\n     * @param {?(PublicKey | string)} [parentAccountOwner] parentAccount is the nameclass for the reverse lookup account. leave empty for SNS.\n     * @returns {(Promise<string | undefined>)}\n     */\n    async reverseLookupNameAccountWithKnownParent(\n        nameAccount: PublicKey | string,\n        parentAccountOwner?: PublicKey | string,\n    ): Promise<string | undefined> {\n        const parser = new TldParser(this.connection);\n        if (parentAccountOwner) {\n            const domainName = await parser.reverseLookupNameAccount(\n                nameAccount,\n                parentAccountOwner,\n            );\n            return domainName;\n        } else {\n            if (typeof nameAccount == 'string') {\n                nameAccount = new PublicKey(nameAccount);\n            }\n            const domainName = await performSNSReverseLookup(\n                this.connection,\n                nameAccount,\n            );\n            return domainName;\n        }\n    }\n\n    /**\n     * reverse lookup for nameAccount public key, to retrieve domain name.\n     * based on protocol.\n     *\n     * @async\n     * @param {(PublicKey | string)} nameAccount\n     * @param {Protocol} [protocol=Protocol.ANS]\n     * @returns {(Promise<string | undefined>)}\n     */\n    async reverseLookupNameAccount(\n        nameAccount: PublicKey | string,\n        protocol: Protocol = Protocol.ANS,\n    ): Promise<string | undefined> {\n        if (typeof nameAccount == 'string') {\n            nameAccount = new PublicKey(nameAccount);\n        }\n        switch (protocol) {\n            case Protocol.ANS:\n                const nameRecordHeaderANS =\n                    await NameRecordHeader.fromAccountAddress(\n                        this.connection,\n                        nameAccount,\n                    );\n                if (!nameRecordHeaderANS) return;\n                const tldParser = new TldParser(this.connection);\n                const tldFound = await tldParser.getTldFromParentAccount(\n                    nameRecordHeaderANS.parentName,\n                );\n                const [tldHouseKey] = findTldHouse(tldFound);\n                const domainNameANS = await tldParser.reverseLookupNameAccount(\n                    nameAccount,\n                    tldHouseKey,\n                );\n                return domainNameANS;\n            case Protocol.SNS:\n                let domainNameSNS = await performSNSReverseLookup(\n                    this.connection,\n                    nameAccount,\n                );\n                return domainNameSNS;\n            default:\n                let domainName: string;\n                domainName = await performSNSReverseLookup(\n                    this.connection,\n                    nameAccount,\n                );\n                if (domainName) return domainName;\n                const nameRecordHeader =\n                    await NameRecordHeader.fromAccountAddress(\n                        this.connection,\n                        nameAccount,\n                    );\n                if (!nameRecordHeader) return;\n                const parser = new TldParser(this.connection);\n                const tld = await parser.getTldFromParentAccount(\n                    nameRecordHeader.parentName,\n                );\n                const [tldHouse] = findTldHouse(tld);\n                domainName = await parser.reverseLookupNameAccount(\n                    nameAccount,\n                    tldHouse,\n                );\n                return domainName;\n        }\n    }\n}\n"]}